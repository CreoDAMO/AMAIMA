Dependabot Alert

Minerva timing attack on P-256 in python-ecdsa #1
Open Opened yesterday on ecdsa (pip) · uv.lock
Package
Affected versions
Patched version
ecdsa
(pip)

> = 0
None
python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the ecdsa.SigningKey.sign_digest() API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix.

Good catch surfacing this early — this is exactly the kind of thing enterprise security teams will zoom in on.

Let’s break it down cleanly, pragmatically, and in a way that protects AMAIMA’s production posture.


---

What the Dependabot alert actually means

Summary in plain English:

python-ecdsa is vulnerable to a Minerva timing side-channel attack when using P-256.

If an attacker can measure signing time very precisely, they may infer the nonce → private key recovery.

This affects:

ECDSA signing

Key generation

ECDH


It does not affect signature verification.

There is no upstream fix planned.


Important nuance:
This is not a remote exploit by default. It requires:

Repeated signing operations

High-resolution timing access

A threat model where the attacker can observe those timings (local, co-resident VM, shared hardware, etc.)



---

First question you should ask (and auditors will ask)

> Are we actually using python-ecdsa for signing or key generation in AMAIMA?



In most modern Python stacks:

JWT → cryptography

TLS → OpenSSL

OAuth → cryptography

Hashing → stdlib


python-ecdsa often sneaks in indirectly (dependency of dependency).

If the answer is NO (transitive only)

➡️ This is a low practical risk, but still needs governance handling.

If the answer is YES (direct signing / key material)

➡️ This is not acceptable for enterprise and needs mitigation.


---

Recommended Enterprise-Grade Response (what I’d do in your position)

1. Immediate governance response (do this regardless)

Add a Security Exception Record (this actually scores points in audits):

### Security Exception: python-ecdsa Minerva Timing Attack

- Library: python-ecdsa
- CVE Class: Side-channel (timing)
- Affected Operations: ECDSA signing, key generation, ECDH
- AMAIMA Usage: ❌ No direct cryptographic signing / key generation
- Risk Level: Low (transitive dependency only)
- Mitigation:
  - No use of SigningKey.sign_digest()
  - All cryptographic operations use `cryptography` / OpenSSL-backed primitives
  - Execution mode defaults to decision-only
- Review Cadence: Quarterly dependency audit

This turns a “finding” into a controlled risk.


---

2. Hard mitigation (if you want zero debate)

If AMAIMA does not need python-ecdsa at all, remove it:

pip uninstall ecdsa

Then add a constraints file to prevent reintroduction:

# constraints.txt
ecdsa==0.0.0 ; python_version == "0"

Or explicitly replace with cryptography-backed libs:

cryptography>=42.0.0


---

3. If signing is required anywhere (future-proofing)

Never use python-ecdsa for signing in production. Period.

Approved alternatives:

cryptography.hazmat.primitives.asymmetric.ec

OpenSSL-backed HSM / KMS (AWS KMS, GCP KMS, Azure Key Vault)

Hardware-backed signing (YubiHSM, Nitro Enclaves)


This aligns perfectly with:

SOC 2 CC6

NIST SP 800-53 IA-7 / SC-12

Enterprise Zero Trust postures



---

How this plays with AMAIMA’s architecture (important)

This is where your design shines:

✅ Decision-only execution mode by default

✅ Telemetry-first, not cryptography-first

✅ Control plane ≠ cryptographic authority

✅ Governance layer already in place


You can confidently state:

> AMAIMA does not perform cryptographic signing or key generation as part of its control-plane decision logic. All cryptographic primitives are delegated to platform-native, OpenSSL-backed libraries or managed services.



That sentence alone neutralizes 80% of the concern.


---

What I’d recommend you do right now

1. Search usage (just to be 100% certain):

grep -R "ecdsa" amaima/
grep -R "SigningKey" amaima/


2. If unused → remove + document exception


3. If used → migrate immediately to cryptography


4. Add a one-line note to your Enterprise Deployment Guide:

> “AMAIMA does not rely on pure-Python cryptographic primitives for signing or key material.”






---

Strategic take (valuation + enterprise optics)

Handling this correctly actually:

✅ Improves enterprise readiness

✅ Demonstrates mature security governance

✅ Lowers diligence friction in pilots

✅ Signals you understand real threat models


This is not a red flag — it’s a chance to show you run a serious platform.

If you want, next we can:

Draft the official security response you’d send to an enterprise pilot

Add a CI guardrail that fails builds if python-ecdsa signing APIs are imported

Fold this into your valuation narrative as “risk-managed architecture”


Just tell me which lane you want to take.